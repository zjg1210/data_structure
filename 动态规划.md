二、动态规划
     动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。
因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。
     动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。
     简单地说，问题能够分解成子问题来解决。
  
  涉及的题型：
    动态基础
    背包问题
    打家劫舍
    股票问题
    子序列问题
    
  解题步骤：
    dp数组以及下标的含义
    递推公式
    dp数组如何初始化
    遍历顺序
    打印dp数组
    
注意：for(int i=0; ; )
        for(j=  ;  ; )
    这两个循环的顺序
    
例子：
  1、斐波那契数列
    分析：
     当n=0时，sum = 1；
     当n=1时，sum = 1;
     当n=2时，sum = 2;
     当n=3时，sum = 3；
     当n=4时，sum = 5；
     ...
     1）得到递推公式： 第n个时，sum=sum(n-1)+sum(n-2);
     2）定义数组： dp[i] 表示第i时的值
                  dp[i]=dp[i-1]+dp[i-2];
     3)数组初始化：
        由前面分析得知，dp[0]=1;
                       dp[1]=1;
     4)遍历顺序：
          for(int i=2;i<n;i++)
          {
             dp[i]=dp[i-1]+dp[i-2];
          }
     5)打印数组
     
  2、爬楼梯 （与斐波那契数列差不多）
     问题：有n个阶梯，你有多少中方法能爬到第n个阶梯
     分析：
        当n=1时，1种
        当n=2时，2种
        当n=3时，3种
        当n=4时，5种
        当n=5时，8种
         ....
      1)得到递推公式：
             有n个阶梯，有sum(n)=sum(n-2)+sum(n-1)种
      2）定义数组：
             dp[i]表示爬到第i个阶梯时，有dp[i]种方法
             dp[i]=dp[i-2]+dp[i-1];
      3）数组初始化：
             由前面分析得：
              知道dp[0]=1是没有意义的
              因此：dp[1]=1;
                    dp[2]=2;
      4)遍历顺序：
            4)遍历顺序：
          for(int i=3;i<n;i++)
          {
             dp[i]=dp[i-1]+dp[i-2];
          }
      5)打印数组
  
  3、背包问题
    A、0-1背包问题：
      题目： 有N件物品和一个容量为V的背包。第i件物品的体积是w[i]，价值是p[i]。求解将哪些物品装入背包可使价值总和最大。

从这个题目中可以看出，01背包的特点就是：每种物品仅有一件，可以选择放或不放。
    
    注意：每个物品的状态只有两种：放与不放，就是0与1
   1）运用二维数组解题：dp[i][j]，表示：在0-i之间任何物品选取放入容量为j的背包中
   2）分析：  (假设三个物品的重量分别为1、3、4，价值分别为：15、30、40，背包的容量为：4)
        容量j:  0  1  2  3  4    
物品i:       1
             2
             3
      对于物品i：
          不放入背包时：得到的价值为：dp[i-1][j]，不放入，为什么还是j，因为不放入物品i，背包的容量是没有变化的，还是j
          放入背包时：  得到的价值为：dp[i-1][j-w[i]]+p[i],其中dp[i-1][j-w[i]]为什么还是i-1,这是因为表示前面i-1个物品的，然后你又放入这个物品进入背包，
                                     所以背包的容量要减去物品i的重量，最后，加上该物品的价值，即为放入物品i之后，背包中的物品的所有价值。
  3)递推公式： 因为要使背包中的物品总价值最大，即为dp[i-1][j]与dp[i-1][j-w[i]]中最大的那个，则可得出递推公式：
               dp[i][j]=dp[i-1][j]+dp[i-1][j-w[i]].
          
  4）遍历顺序：
              for(int i=1;i<N;i++)  //先遍历物品
                 for(int j=0;j<v;j++)  //遍历容量
              
              也可以颠倒过来，注意这只是针对二维数组解题时，一维时不适用
      初始化：
        容量j:  0   1  2  3  4    
物品i:       1  0  15 15 15 15
             2  0  -1 -1 -1 -1
             3  0  -1 -1 -1 -1

创建和初始化数组：
     vector<vector<int>>dp(weight+1,0),vector<int>())
     
     
     
     
     
     
     
     
     
     
     
     
